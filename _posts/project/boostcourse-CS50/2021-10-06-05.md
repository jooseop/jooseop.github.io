---
title:  "Boost Course CS50 Study 4주차. 알고리즘"
excerpt:

categories:
  - cs50

toc: true
toc_sticky: true
 
date: 2021-10-06
---

# 알고리즘

-   닫혀있는 사물함
-   컴퓨터는 사람처럼 전체를 볼 수 없다.

# 검색 알고리즘

## 선형검색

```c
For i from 0 to n-1
  if i == 50:
    Return True
Return False
```

## 이진검색

```c
if no items:
  Return False

if middle item is 50:
  Return True
else if 50 < middle item:
  Search left half
else if 50 > middle item:
  Search right half
```

# 알고리즘 표기법 (시간복잡도)

-   Big-O : 실행 시간의 상한 (최악)

| Big O    |                                                              |                               |
| -------- | ------------------------------------------------------------ | ----------------------------- |
| O(1)     | 한번                                                         | push, pop                     |
| O(logn)  | 반씩 줄어듬                                                  | 이진 트리                     |
| O(n)     | 한바퀴, for                                                  | 정렬 말고 무작정 탐색(고르기) |
| O(nlogn) | n번 동작을 logn번 한다                                       | 병합정렬, 힙정렬, 퀵정렬      |
| O(n^2)   | 이중 for문, (개수가 하나씩 줄어들어도) 같은 과정을 반복한다. | 버블 정렬, 선택정렬           |
| O(2^n)   |                                                              | 피보나치 수열                 |

-   Ω(Omega) : 실행 시간의 하한
-   θ(Theta) : 상한과 하한이 같을 때 - 중단의 여부와 상관없이 진행한다.

# 선형 검색

-   자료가 정렬되어 있지 않거나, 정보가 없어 하나씩 찾아봐야 하는 경우에 유용
-   검색 이전에 정렬이 필요하다. 정렬을 하지 않으면, 선형 검색을 해야한다.
-   구조체

```c
typedef struct{
    string name;
    string number;
} person;

int main(void){
    person people[4];
    people[0].name = "Kim";
    people[0].number = "111-111-1111";
}
```

# 버블 정렬

-   큰 숫자는 오른쪽으로 거품이 떠오르듯 움직인다.
-   붙어있는 한쌍이 계속 바뀜
-   시간복잡도는 O(n^2)이다.

```c
for _ from 0 to n-1:
  for i from 0 to n-2:
    if i와 i+1이 정렬이 안되있으면:
      자리를 바꿔준다.
```

# 선택 정렬

-   배열의 가장 작은 수(혹은 가장 큰 수)를 찾아 첫번째 위치(혹은 가장 마지막 위치)의 수와 교환해준다.
-   하나를 선택해서, 나머지들 중 하나와 바꿈
-   시간 복잡도는 O(n^2)이다.

```c
for i from 0 to n-1:
  for j = i+1 from i to n-1:
    j 숫자들 중에서, 가장 작은 수를 찾는다.
  가장 작은 숫자와 i번째 숫자를 바꾼다.
```

# 정렬 알고리즘의 실행 시간

-   버블 정렬의 개선 : 중단 지점을 개선하여, 하한은 Ω(n)이 된다.

```c
스왑이 일어나지 않을 때까지만 반복한다:
// 스왑이 일어나지 않았다는 것은 정렬이 끝난 것을 의미
// 정렬하려는 가장 작은 숫자가 제대로 자리에 위치함을 의미 
  for i from 0 to n-2:
    if i와 i+1이 정렬이 안되있으면:
      자리를 바꿔준다.
```

# 재귀

-   for문 대신, 본인 스스로를 호출해서 동작을 반복할 수 있는 함수
-   구성
    -   시작점(호출의 마지막, 동작 내용의 실행 시작점)
    -   함수 호출
    -   동작 내용

# 병합 정렬

-   데이터를 반으로 나누어 간다(logn)
-   시간 복잡도 : O(nlogn)
-   임시 메모리를 사용
-   분할하는 과정 & 병합하는 과정
    -   재귀의 과정
    -   일단 분할을 한다. 그리고 시작점(호출의 마지막)에서 병합을 동작 실행을 시작한다.
